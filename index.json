[{"content":"1. 起因：震惊！朋友亲手整合的Minecraft Java版整合包由于Mod数量太多，新手玩家居然完全Hold不住\u0026hellip;   朋友自己组了一个MC整合包，足足有310个模组，模组加载器初始化后340个，基本涵盖了MC比较好玩和经典的模组。经过测试，整合包能够正常地在windows和macOS上跑起来，我们前期打算边玩边测试，有问题再慢慢调。\n   玩MC肯定要联机，我们偷懒地直接通过内网穿透的方式进行远程联机，玩了几天后发现还是有些不方便，这种联机意味着作为服务器的一方要随时开着游戏才能保证另一方想玩的时候就玩，但是我们不想改变现状，耗费了约几秒钟提出了以下补偿方案：\n   主机方7✖️24小时开着自己电脑 其他玩家需要玩的时候主机方随时响应 使用类似坚果云的同步工具同步存档 \u0026hellip;      经过研究，上述方案几乎全部拉垮\n（废案）1. 主机方7✖️24小时开着自己电脑\n注：7x24小时挖矿它不香吗？\n（废案）2. 其他玩家需要玩的时候主机方随时响应\n注：技术可以实现（远程触发WOL + 开机自启服务之类的操作），人工也可以实现（接到微信消息打开游戏），当事人不愿意体验下班oncall遂放弃。\n（废案）3. 使用类似坚果云的同步工具同步存档\n注：表面上看，方案可行，但暗藏个人存档数据覆盖本地存档的诸多问题，比如同步存档后你登录后可能是其他主机的角色，需要进一步研究server.dat文件，实际操作层面是在挖更多坑。\n  2. 稍微操作一下：直接将整合包迁移到Minecraft Forge Server不香吗？ 利用现有资源快速部署   整合包在本地大概需要至少4～6G左右内存，之前搞的一个4U8G云服务器跑一个Minecraft问题应该不大。\n  综上所述，直接在云服务器部署一个MC服务器反而最舒服，MC如何开服这种问题就不用细说了，各大搜索引擎大量这类内容。我部署了[minecraft forge 1.12.2 - 14.23.5.2855 + Minecraft Server1.12.2版本](Downloads for Minecraft Forge for Minecraft 1.12.2)\n  然后就是导入整合包的模组，再运行发现失败了，查看崩溃日志发现有一个Mod异常，通过检索资料了解到，该mod只需要在客户端安装就行，所以我移除了该Mod，然而继续运行仍然崩溃。\ncp -r /your/pkg/.minecraft/mods /your/path/mods    再仔细查看日志，找到当中建议移除的40多个“可能引起异常”Mod，二话不说直接把提及的Mod都移除了，不过结果并不美满，forge server依旧直接崩溃了。\n    不香，至少不是开箱即用的方案  部署虽然失败了，原因很清楚：某些模组无法在服务器上运行；对此，我得到如下两个解决方案：    反复运行forge服务器（每次完整加载所有340个模组需要6~10分钟），查看每次产生的crash-logs，并根据出现的exception移除对应模组； mods目录初始为空，每次添加一部分整合包的模组进来，然后反复运行，出现exception的模组就不往mods目录加；     显然，上述两种方案，操作不难，却相当麻烦；作为一名新手玩家，我不打算一次性搞懂每个模组的功能，但是我打算进一步研究Minecraft模组结构，看看是否能得到一些帮助。  3. 折腾：研究模组之间依赖关系 对于新手玩家可能有许多困惑  各种模组加载器有什么不同？例如forge，fabric等 模组加载器加载Mod的流程是怎么样的？ 怎么样通过一个jar包了解到Mod的具体信息？对于FML是怎么做的？ FML每次启动都报这么多error和warning，为什么最终还是能启动，并且模组功能基本也没有什么影响？ \u0026hellip;   以上困惑也是我的困惑，我们知道Mod基本都是一个jar包的形式，从直接观察的情况来看，模组加载器读取了jar包后，能够验证Mod适配的MC版本，能够了解Mod的依赖其他Mod的信息，能够读取版本和作者等基础信息；所以现在我们需要做的就是去分析模组加载器是如何得到这些信息的。  直接阅读对照两个Mod的源码   Mod基本上都是开源的，这里我选了两个有依赖关系的模组：更多鸡(chickens)和更多鸡扩展(more chickens)，chickens模组是在原版MC的基础上增加的鸡种群和产物，more chicken是在chickens模组的基础上再次扩展种群和产物，也就是说more chickens依赖chickens模组\n# 对应Minecraft 1.12.2版本 Chickens: 6.1.0 MoreChickens: 3.2.0    如果依赖不正确，模组加载器会提示required异常，如下图所示\n     阅读more chickens源码，发现一些依赖chickens的迹象\n  com.gendeathrow.morechickens.core.ChickensMore.java确实引入了chickens注册鸡实体的相关类\nimport com.setycz.chickens.registry.ChickensRegistry; import com.setycz.chickens.registry.ChickensRegistryItem;   build.gradle中dependencies里确实声明了chickens模组的依赖\ndependencies { deobfCompile \u0026#34;chickens:chickens:${chickens_version}\u0026#34; ... }   gradle.properties文件里给出了chickens的相应版本，这个版本号与前面MC运行时提示的版本号是一致的\n# minecraft 版本 minecraftversion=1.12 # chickens模组版本 chickens_version=6.0.2     结论是我们能够根据源码的项目依赖轻松获取各种静态依赖信息，然而jar包是编译好的，并且不是所有Mod都是开源的，这些情况如何获取Mod信息；当然，我们可以针对jar包做静态依赖分析，分析目标模组jar包需要依赖哪些jar包，先不说结果是否一直，我想问模组加载器也是这么干的吗？\n  研究Forge模组加载器(Forge Mod Loader, FML)的加载行为   分析MinecraftForge 1.12.x源码中FMLnet.minecraftforge.fml部分\n  首先，如下图，我们先看一下MinecraftForge启动后，FML做了什么事情\n   从上图可以看出，FML在完成一系列初始化配置后，最终在第五步identifyMods这个方法中完成了Mod的识别，所以接下来我们进一步看FML到底是如何识别Mod的，如下图\n   我们现在可以了解到FML实际上通过一个JarDiscoverer类的discover方法实现了jar包的解析，我们通过源码继续解读分析\n// class JarDiscoverer implements ITypeDiscoverer  // discover方法 // 最终返回ModContainer类，ModContainer是一个interface @Override public List\u0026lt;ModContainer\u0026gt; discover(ModCandidate candidate, ASMDataTable table) { // 省略...  try (JarFile jar = new JarFile(candidate.getModContainer())) { // 读取mcmod.info文件  ZipEntry modInfo = jar.getEntry(\u0026#34;mcmod.info\u0026#34;); // 省略...  // 读取json文件  findClassesJSON(candidate, table, jar, foundMods, mc); // 省略...  // 读取class字节码  findClassesASM(candidate, table, jar, foundMods, mc); } // ... }   discover方法使用try with resources尝试读取了jar包中的mcmod.info文件，并且还继续调用另两个方法findClassesJSON和findClassesASM读取文件，我们继续往下看\n  findClassesASM显然是读取**.class**文件字节码的\nprivate void findClassesASM(...) { // 省略...  // 遍历匹配jar.entries()中的每个文件，匹配  Matcher match = classFile.matcher(ze.getName()); if (match.matches()) { // 省略...  ASMModParser modParser = new ASMModParser(inputStream); modParser.validate(); modParser.sendToTable(table, candidate); ModContainer container = ModContainerFactory.instance().build(modParser, candidate.getModContainer(), candidate); // 省略...  // 解析完成，添加ModContainer实例到已发现Mod的List中  foundMods.add(container); // 省略...  } }   findClassesJSON负责读取JSON文件\nprivate void findClassesJSON(...) throws IOException { // 读取META-INF/fml_cache_annotation.json文件  ZipEntry json = jar.getEntry(JsonAnnotationLoader.ANNOTATION_JSON); Multimap\u0026lt;String, ASMData\u0026gt; annos = JsonAnnotationLoader.loadJson(jar.getInputStream(json), candidate, table); // 根据上面读取到annos提供的class数据，遍历生成ModContainer  for (...) { for (ASMData data : annos.get(type.getClassName())) { // ...  ModContainer ret = ctr.newInstance(data.getClassName(), candidate, data.getAnnotationInfo()); // 添加ModContainer实例到已发现Mod的List中  foundMods.add(ret); } } }   完成上面的分析后我们了解几件事情  需要读取jar包中的mcmod.info文件（如果文件存在的话），以获取mod基本信息； 需要读取META-INF/fml_cache_annotation.json文件，获取class信息； 如果没有META-INF/fml_cache_annotation.json文件则直接通过ASM加载class文件字分析类的信息；   具体数据格式在下一节说明\n 4. 试着做一个小工具 入口   经过源码分析，我们基本了解了MinecraftForge是如何识别Mod的，其中Mod(jar包)中关键的文件有下面几种：\n   mcmod.info文件，格式形如：  [ { \u0026#34;modid\u0026#34;: \u0026#34;morechickens\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;More Chickens\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Adds Tinkers Construct and Draconic Evolution chickens...\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;3.2.0\u0026#34;, \u0026#34;mcversion\u0026#34;: \u0026#34;1.12.2\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://minecraft.curseforge.com/projects/more-chickens\u0026#34;, \u0026#34;updateUrl\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;authorList\u0026#34;: [ \u0026#34;GenDeathrow\u0026#34; ], \u0026#34;credits\u0026#34;: \u0026#34;Chickens Mod, GameWalker, ACGaming, MrAmericanMike\u0026#34;, \u0026#34;logoFile\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;screenshots\u0026#34;: [], \u0026#34;dependencies\u0026#34;: [ \u0026#34;Chickens Mod\u0026#34; ] } ]   META-INF/fml_cache_annotation.json文件，格式形如：  { \u0026#34;com/gendeathrow/morechickens/core/ChickensMore\u0026#34;: {...}, \u0026#34;com/gendeathrow/morechickens/core/ModItems\u0026#34;: {...}, \u0026#34;com/gendeathrow/morechickens/handlers/EggTooltips\u0026#34;: {...}, \u0026#34;com/gendeathrow/morechickens/handlers/SpecialChickenHandler\u0026#34;: {...}, \u0026#34;com/gendeathrow/morechickens/modHelper/ActuallyAdditionsAddon\u0026#34;: {...}, \u0026#34;com/gendeathrow/morechickens/modHelper/BotaniaAddon\u0026#34;: {...}, \u0026#34;com/gendeathrow/morechickens/modHelper/ExtraUtilitiesAddon\u0026#34;: {...}, \u0026#34;com/gendeathrow/morechickens/modHelper/RefinedStorageAddon\u0026#34;: {...} }   展开后如下\n{ \u0026#34;com/gendeathrow/morechickens/core/ChickensMore\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;com/gendeathrow/morechickens/core/ChickensMore\u0026#34;, \u0026#34;annotations\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;CLASS\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Lnet/minecraftforge/fml/common/Mod;\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;com/gendeathrow/morechickens/core/ChickensMore\u0026#34;, \u0026#34;values\u0026#34;: { \u0026#34;acceptedMinecraftVersions\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;[1.12.2]\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;required-after:chickens@[6.1.0,)...\u0026#34; }, \u0026#34;modid\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;morechickens\u0026#34; }, \u0026#34;name\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;More Chickens\u0026#34; }, \u0026#34;version\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;3.2.0\u0026#34; } } }, { \u0026#34;type\u0026#34;: \u0026#34;FIELD\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Lnet/minecraftforge/fml/common/Mod$Instance;\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;instance\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;morechickens\u0026#34; } }, ] } }   java class文件，经过gradle构建后生成的class文件  1, com/gendeathrow/morechickens/core/ChickensMore.class 2, com/gendeathrow/morechickens/core/configs/JsonConfig.class 3, com/gendeathrow/morechickens/core/configs/MoreChickenConfig.class 4, com/gendeathrow/morechickens/core/ModItems.class 5, com/gendeathrow/morechickens/core/proxies/ClientProxy.class 6, com/gendeathrow/morechickens/core/proxies/CommonProxy.class 7, com/gendeathrow/morechickens/handlers/EggTooltips.class 8, com/gendeathrow/morechickens/handlers/SpecialChickenHandler.class 9, com/gendeathrow/morechickens/items/RandomEnchantedBook.class 10, com/gendeathrow/morechickens/items/RandomPotion.class 11, com/gendeathrow/morechickens/items/SolidRF.class 12, com/gendeathrow/morechickens/items/SolidXp.class ...     知道了这些，事情就比较容易了，针对第1种和第2种，只要Mod中含有对应文件，那么读取文件再解析文本就能得到Mod的信息\n  做成什么样？怎么做？  工具需要具备以下功能  能够分析mods目录中所有mod的依赖关系 给出一个Mod能够分析出它对应的依赖信息   方法  读取解析mcmid.info文件 读取解析JSON文件 读取解析.class文件    开发过程   采用Go语言开发\n  解析的数据结构如下：\n// asm信息，通过json或class解析 type ASMInfo struct { Name string `json:\u0026#34;name\u0026#34;` Interfaces []string `json:\u0026#34;interfaces\u0026#34;` Annotations []Annotation `json:\u0026#34;annotations\u0026#34;` ById map[int]Annotation } type Annotation struct { Type TargetType `json:\u0026#34;type\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` Target string `json:\u0026#34;target\u0026#34;` Id int `json:\u0026#34;id\u0026#34;` Value ValueHolder `json:\u0026#34;value\u0026#34;` Values map[string]ValueHolder `json:\u0026#34;values\u0026#34;` PValues map[string]interface{} } // 解析mcmod.info type ModInfo struct { ModId string `json:\u0026#34;modid\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` Description string `json:\u0026#34;description\u0026#34;` Version string `json:\u0026#34;version\u0026#34;` McVersion string `json:\u0026#34;mcversion\u0026#34;` Url string `json:\u0026#34;url\u0026#34;` UpdateUrl string `json:\u0026#34;updateUrl\u0026#34;` Authors []string `json:\u0026#34;authors\u0026#34;` AuthorList []string `json:\u0026#34;authorList\u0026#34;` Credits string `json:\u0026#34;credits\u0026#34;` LogoFile string `json:\u0026#34;logoFile\u0026#34;` Screenshots []string `json:\u0026#34;screenshots\u0026#34;` Dependencies []string `json:\u0026#34;dependencies\u0026#34;` }   关键函数\n// 载入Mod文件 core.LoadMod // 解析Mod之间以来关系 core.ParseDependencies // 分析Mod依赖 core.Analyze   编译\n go build -o mmm\n   最终效果   命令一览\n  see命令及演示\n功能包括：指定mods目录，输出依赖关系表\n./mmm help see show all status Usage: mmm see [flags] Flags: -a, --analyze string analyze mods\u0026#39; dependencies -d, --directory string specific the \u0026#34;mods\u0026#34; directory -h, --help help for see -o, --output string specific the output path -p, --print stringArray must be \u0026#34;jar\u0026#34; or \u0026#34;files\u0026#34;     dep命令及演示\n功能包括：分析指定Mod，指定目录后能够分析Mod对应的依赖文件\n./mmm help dep analyze mod dependencies Usage: mmm dep [flags] Flags: -d, --directory string specific the \u0026#34;mods\u0026#34; directory -f, --file string specific a mod file -h, --help help for dep     开发总结  实现通过一个jar包查询Mod依赖并能够根据提供的目录指出依赖对应文件的功能 实现指定mods目录所有mod之间依赖关系分析以及分析统计结果并输出  5. 问题解决与结论 令人遗憾的事实   机械化而且重复的劳动不是完全没必要的\n  Mod开发者不一定完全遵守开发规范（约定），有时候连模组加载器都束手无策\n  小工具并不能直接解决mod冲突/异常/报错等问题\n  令人兴奋的几点  Mod开发生态非常好，主要有以下几点   Mod开发难度相对较小，如果有需要的话，你甚至能够自己动手修复BUG（接盘）\n  gradle相对maven确实麻烦一些，但是官方以及第三方都提供了各种maven源（文章底部分享）\n   最终移除了三个Mod就解决了问题，服务器完美运行 云服务器稳定工作，现在能够随时畅玩MC！  结论 小题大做了。\n  相关链接 / 分享 MinecraftForge 源码 MinecraftForge/MinecraftForge(github.com)\nminecraft forge maven 源 1 Minecraft Forge repository\n2 Browse minecraft - Crystal (lss233.com)\ngo语言实现的jvm zxh0/jvm.go (github.com)\nwanghongfei/mini-jvm (github.com)\n本文开源项目 libvulcan/mmm(待上传)\nlibvulcan/jar-dep(待上传)\nMinecraft到底有多少种开服工具？ itzg/docker-minecraft-server(github.com)：项目中定位文件形如start-deploy{开服工具名}，就是目前常见的开服工具，其中Vanilla表示原版Minecraft。\n","permalink":"https://blog.libvulcan.com/posts/%E7%BA%AF%E6%8A%98%E8%85%BE-minecraft-forge%E6%A8%A1%E7%BB%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E5%88%86%E6%9E%90/","summary":"1. 起因：震惊！朋友亲手整合的Minecraft Java版整合包由于Mod数量太多，新手玩家居然完全Hold不住\u0026hellip;   朋友自己组了一个MC整合包，足足有310个模组，模组加载器初始化后340个，基本涵盖了MC比较好玩和经典的模组。经过测试，整合包能够正常地在windows和macOS上跑起来，我们前期打算边玩边测试，有问题再慢慢调。\n   玩MC肯定要联机，我们偷懒地直接通过内网穿透的方式进行远程联机，玩了几天后发现还是有些不方便，这种联机意味着作为服务器的一方要随时开着游戏才能保证另一方想玩的时候就玩，但是我们不想改变现状，耗费了约几秒钟提出了以下补偿方案：\n   主机方7✖️24小时开着自己电脑 其他玩家需要玩的时候主机方随时响应 使用类似坚果云的同步工具同步存档 \u0026hellip;      经过研究，上述方案几乎全部拉垮\n（废案）1. 主机方7✖️24小时开着自己电脑\n注：7x24小时挖矿它不香吗？\n（废案）2. 其他玩家需要玩的时候主机方随时响应\n注：技术可以实现（远程触发WOL + 开机自启服务之类的操作），人工也可以实现（接到微信消息打开游戏），当事人不愿意体验下班oncall遂放弃。\n（废案）3. 使用类似坚果云的同步工具同步存档\n注：表面上看，方案可行，但暗藏个人存档数据覆盖本地存档的诸多问题，比如同步存档后你登录后可能是其他主机的角色，需要进一步研究server.dat文件，实际操作层面是在挖更多坑。\n  2. 稍微操作一下：直接将整合包迁移到Minecraft Forge Server不香吗？ 利用现有资源快速部署   整合包在本地大概需要至少4～6G左右内存，之前搞的一个4U8G云服务器跑一个Minecraft问题应该不大。\n  综上所述，直接在云服务器部署一个MC服务器反而最舒服，MC如何开服这种问题就不用细说了，各大搜索引擎大量这类内容。我部署了[minecraft forge 1.12.2 - 14.23.5.2855 + Minecraft Server1.12.2版本](Downloads for Minecraft Forge for Minecraft 1.12.2)\n  然后就是导入整合包的模组，再运行发现失败了，查看崩溃日志发现有一个Mod异常，通过检索资料了解到，该mod只需要在客户端安装就行，所以我移除了该Mod，然而继续运行仍然崩溃。\ncp -r /your/pkg/.minecraft/mods /your/path/mods    再仔细查看日志，找到当中建议移除的40多个“可能引起异常”Mod，二话不说直接把提及的Mod都移除了，不过结果并不美满，forge server依旧直接崩溃了。","title":"小题大做 - Minecraft Forge模组依赖关系分析"},{"content":"为什么会有blog.libvulcan.com ？  对于知识记录的载体，我更偏向于长期使用OneNote和Notion这类平台，这类平台往往功能十分强大，能够轻松的进行团队协作和内容分享。但blog的意义有些不同，它多了一种不同的创作的感觉，你就像真正的作家将你的作品发布，也许永远无人问津，“销量”惨淡；也许你绞尽脑汁，还是没法起笔下一部作品；也许很快你就淡忘自己还是一位“作家”，所有的这些，对于blog和你来说都无关紧要。 blog.libvulcan.com为何存在？无关自由、无关意义、无关分享，只是因为它在域名商被我注册了。  为什么是Github Page ？  个人接触和使用blog实际上有一段时间了，从个人经验上，整体分为以下几类：  自建服务器  Flask + Layui 搭建 Gin + Vue 搭建 Hexo、Hugo 静态内容生成框架   服务商托管  Github Page Gitee Page Coding Page   博客平台  CSDN 博客园 简书     造轮子（非必要的）、交给服务商、交给充斥繁杂推荐的平台这三类对比下来，对于blog.libvulcan.com来说，毫无疑问我选择服务商托管。  关于我 brand new\n关于博客内容、技术、游戏、服务器等问题请发邮件联系我，需要进一步交流可以留下你的telegram、discord、linkedin、wechat或QQ。\n联系邮箱：点我 \u0026raquo;\n","permalink":"https://blog.libvulcan.com/about/","summary":"为什么会有blog.libvulcan.com ？  对于知识记录的载体，我更偏向于长期使用OneNote和Notion这类平台，这类平台往往功能十分强大，能够轻松的进行团队协作和内容分享。但blog的意义有些不同，它多了一种不同的创作的感觉，你就像真正的作家将你的作品发布，也许永远无人问津，“销量”惨淡；也许你绞尽脑汁，还是没法起笔下一部作品；也许很快你就淡忘自己还是一位“作家”，所有的这些，对于blog和你来说都无关紧要。 blog.libvulcan.com为何存在？无关自由、无关意义、无关分享，只是因为它在域名商被我注册了。  为什么是Github Page ？  个人接触和使用blog实际上有一段时间了，从个人经验上，整体分为以下几类：  自建服务器  Flask + Layui 搭建 Gin + Vue 搭建 Hexo、Hugo 静态内容生成框架   服务商托管  Github Page Gitee Page Coding Page   博客平台  CSDN 博客园 简书     造轮子（非必要的）、交给服务商、交给充斥繁杂推荐的平台这三类对比下来，对于blog.libvulcan.com来说，毫无疑问我选择服务商托管。  关于我 brand new\n关于博客内容、技术、游戏、服务器等问题请发邮件联系我，需要进一步交流可以留下你的telegram、discord、linkedin、wechat或QQ。\n联系邮箱：点我 \u0026raquo;","title":"关于"}]